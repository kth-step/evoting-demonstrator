structure Base64 =
  struct

(* number to list of binary *)
(*
int_to_bitlist 5;
int_to_bitlist 4;
int_to_bitlist 1;
int_to_bitlist 0;
*)
local

fun int_to_bitlist_acc n =
  if n = 0 then []
  else
    (n mod 2) :: int_to_bitlist_acc (n div 2) ;
fun int_to_bitlist n = List.rev (int_to_bitlist_acc n) ;

(*
n2l2 5;
n2l2 4;
n2l2 1;
n2l2 0;
*)

fun n2l2 n =
  if n < 2 then
    [n mod 2]
  else  (n mod 2) :: n2l2 (n div 2);


(* remove leading zeros from a list of bits *)
(*
normalise_bitlist [0, 0, 1] ;
normalise_bitlist [0, 1] ;
*)

fun normalise_bitlist xs =
  List.dropUntil (fn x => x <> 0) xs ;

(* binary list to number *)
(*
bitlist_to_int (int_to_bitlist 35);
bitlist_to_int (int_to_bitlist 5);
bitlist_to_int (int_to_bitlist 4);
bitlist_to_int (int_to_bitlist 1);
bitlist_to_int [];
bitlist_to_int [0, 0];
*)

fun bitlist_to_int_acc ls e acc =
  case ls of
    [] => acc
  | (x::xs) =>
      if x > 0 then
        bitlist_to_int_acc xs (e*2) (acc + e)
      else
        bitlist_to_int_acc xs (e*2) acc ;
fun bitlist_to_int xs =
    bitlist_to_int_acc
      (List.rev (normalise_bitlist xs)) 1 0 ;

(* prepends list with a padding *)
(*
padlist 10 (int_to_bitlist 35);
padlist 3 (int_to_bitlist 35);
padlist 5 (int_to_bitlist 5);
*)

fun padlist padding ls = List.pad_left 0 padding ls ;

(* fold-like with window of size n *)
(*
val s = List.map Char.ord (String.explode "This is a random text");
take_map 3 (fn x => x) s ;
take_map 2 (fn x => x) s ;
take_map 1 (fn x => Char.chr (List.hd x)) s ;
*)

fun take_map n f ls =
  case ls of
    [] => []
  | _ => f (List.take ls n) :: take_map n f (List.drop ls n) ;

(* base64 encoding *)
(*
val x = List.map Char.ord (String.explode "Manning") ;
val x = List.map Char.ord (String.explode "Hallo Welt!") ;
val x = List.map Char.ord (String.explode "Hallo W") ;
String.implode (base64_enc base64_str x );
*)

fun base64_enc encoding x =
  let
    val len = List.length x ;
    val padlen = (3 - len) mod 3;
    val bitlist =
      List.concat (List.map (fn x => padlist 8 (int_to_bitlist x)) x) ;
    (* ensure multiple of 3 *)
    val bitlist =
      List.pad_right 0 (8 * len + 2 * padlen) bitlist ;
    val enc = take_map 6 bitlist_to_int bitlist ;
    val enc' =
      List.map Option.valOf
        (List.map (Alist.lookup encoding) enc ) ;
    val padding = List.genlist (fn i => #"=") padlen ;
  in
    enc' @ padding
  end ;

fun swap x = (snd x,fst x) ;

(* map swap encoding *)

(* base64 decoding *)
(*
val x = "TWFubmluZw==" ;
val x = "SGFsbG8gV2VsdCE=" ;
val x = "SGFsbG8gVw==" ;
val x = "SGFsbG8gVw" ;
val x = "dGVzdCBlbmNvZGUK" ;
String.implode (List.map Char.chr (base64_dec base64_str x)) ;
*)

fun base64_dec encoding x =
  let
    (* discard padding *)
    val x = List.takeUntil (fn x => x = #"=") (String.explode x) ;
    val x =
      List.map Option.valOf
        (List.map (Alist.lookup (List.map swap encoding)) x ) ;
    val len = List.length x ;
    val padlen = (4 - len) mod 4;
(*
len mod 4   remove padding zeros (to multiple of 8)
1: 6 _ _ _  - 6
2: 6 6 _ _  - 4
3: 6 6 6 _  - 2
*)
    val bitlist =
      List.concat (List.map (fn x => padlist 6 (int_to_bitlist x)) x) ;
    val bitlist = List.take bitlist (6 * len - (padlen * 2)) ;
  in
    take_map 8 bitlist_to_int bitlist
  end ;


(*
base64    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
base64url "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
*)

fun base64_str u =
  List.mapi (fn i => fn x => (i,x))
  (String.explode
  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/") ;

fun base64url_str u =
  List.mapi (fn i => fn x => (i,x))
  (String.explode
  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_") ;

in (* local *)

  fun dec x = base64_dec (base64_str()) x;
  fun enc x = base64_enc (base64_str()) x;
  fun url_dec x = base64_dec (base64url_str()) x;
  fun url_enc x = base64_enc (base64url_str()) x;

end; (* local *)

end; (* Base64 *)

(*
vim: ft=sml
*)
